
test:
  api_namespace: two
  slug: test-second
  label: Test API 2
  enabled: true
  metadata: {
              "api_key": "x-api-key-foo",
              "bearer_token": "foo"
            }
  model_definition: |
    class ExternalApiModelExample
      def initialize(parameters)  
        # do init stuff
      end
      def start
        return true
      end

      def log
        return true
      end
    end
    # at the end of the file we have to implicitly return the class 
    ExternalApiModelExample
open_json_server:
  api_namespace: two
  slug: test-second
  label: Test API 2
  enabled: true
  metadata:  {
                "api_key": "x-api-key-foo",
                "bearer_token": "foo"
              }
  model_definition: |
    class OpenJsonServer
      def initialize(parameters)  
        @external_api_client = parameters[:external_api_client]
        @base_url = "https://jsonplaceholder.typicode.com/todos/1"
      end
      def start
        response = HTTParty.get(@base_url).body
        @external_api_client.api_namespace.api_resources.create(
          properties: JSON.parse(response).deep_symbolize_keys
        )
      end

      def log
        return true
      end
    end
    # at the end of the file we have to implicitly return the class 
    OpenJsonServer
bishop_monitoring:
  api_namespace: monitoring_targets
  slug: bishop-monitoring
  label: Bishop Monitoring in a box
  enabled: true
  metadata: {}
  model_definition: |
    class BishopMonitoring
      def initialize(parameters)  
        @external_api_client = parameters[:external_api_client]
        @log_incidents_to_namespace = @external_api_client.api_namespace.properties["log_incidents_to"]
        @targets = @external_api_client.api_namespace.api_resources
        @timeout_in_seconds = 30
      end
      def start
        logger_namespace = ApiNamespace.find_by!(slug: @log_incidents_to_namespace)
        @targets.each do |target|
          url = target.properties["url"]
          start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
          latency = 0
          begin
            response = HTTParty.get(url, follow_redirects: true, timeout: @timeout_in_seconds)
            case response.code 
              when 500..600
                raise StandardError.new "server returned #{response.code}"
            end


            finish = Process.clock_gettime(Process::CLOCK_MONOTONIC)
            latency = ((finish - start) * 1000).round
          rescue StandardError => e
            logger_namespace.api_resources.create!(
              properties: {
                slug: url,
                error: e.message,
                notification_sent: false,
                latency: latency
              }
            )
            updated_target_properties = {
              "healthy": false,
              "alarm_raised": false,
              "last_checked_at": Time.now,
              "latency": 0,
              "error_message": e.message
            }
            target.update!(
              properties: target.properties.merge(updated_target_properties)
            )
            #after handling the error case, we need to bubble it up to the job
            raise
          else
            updated_target_properties = {
              "healthy": true,
              "alarm_raised": false,
              "last_checked_at": Time.now,
              "latency": latency,
              "error_message": nil
            }
            target.update!(
              properties: target.properties.merge(updated_target_properties)
            )
          end
        end
      end

      def log
        return true
      end
    end
    # at the end of the file we have to implicitly return the class 
    BishopMonitoring
bishop_tls_monitoring:
  api_namespace: monitoring_targets
  slug: bishop-tls-monitoring
  label: TLS monitoring in a box
  enabled: true
  metadata: {}
  model_definition: |
    class BishopTlsMonitoring
      def initialize(parameters)  
        @external_api_client = parameters[:external_api_client]
        @log_incidents_to_namespace = @external_api_client.api_namespace.properties["log_incidents_to"]
        @targets = @external_api_client.api_namespace.api_resources
        @timeout_in_seconds = 30
      end
      def start
        logger_namespace = ApiNamespace.find_by!(slug: @log_incidents_to_namespace)
        @targets.each do |target|
          url = target.properties["url"]
          start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
          latency = 0
          begin
            uri = URI::HTTPS.build(host: URI(url).host)
            response = Net::HTTP.start(uri.host, uri.port, :use_ssl => true)
            cert = response.peer_cert
            two_weeks = 14 * 86400 # 14 * One Day
            if Time.now + two_weeks > cert.not_after
              raise "TLS/SSL certificate for #{uri} is expiring soon. Expiry at: #{cert.not_after}"
            end
            finish = Process.clock_gettime(Process::CLOCK_MONOTONIC)
            latency = ((finish - start) * 1000).round
          rescue StandardError => e
            logger_namespace.api_resources.create!(
              properties: {
                slug: url,
                error: e.message,
                notification_sent: false,
                latency: latency
              }
            )
            updated_target_properties = {
              "healthy": false,
              "alarm_raised": false,
              "last_checked_at": Time.now,
              "latency": 0,
              "error_message": e.message
            }
            target.update!(
              properties: target.properties.merge(updated_target_properties)
            )
            #after handling the error case, we need to bubble it up to the job
            raise
          else
            updated_target_properties = {
              "healthy": true,
              "alarm_raised": false,
              "last_checked_at": Time.now,
              "latency": latency,
              "error_message": nil
            }
            target.update!(
              properties: target.properties.merge(updated_target_properties)
            )
          end
        end
      end

      def log
        return true
      end
    end
    # at the end of the file we have to implicitly return the class 
    BishopTlsMonitoring
vacuum_job:
  api_namespace: one
  slug: vacuum-job
  label: VacuumJob
  enabled: true
  metadata: {
            'ORDER': 'descending',
            'DIMENSION': 'created_at',
            'BATCH_SIZE': '5',
            'API_NAMESPACE_ID': '1',
            'OLDER_THAN': '2880' # 2 days (in minutes)
          }
  model_definition: |
    class VacuumJob
      def initialize(parameters)  
        @external_api_client = parameters[:external_api_client]
      end

      def start
        # Fetching provided inputs (namespaceid, batch_size, dimension, order, time_before)
        api_namespace_id = @external_api_client.metadata["API_NAMESPACE_ID"]
        batch_size = @external_api_client.metadata["BATCH_SIZE"]
        dimension = @external_api_client.metadata["DIMENSION"]
        order = @external_api_client.metadata["ORDER"].upcase.starts_with?('ASC') ? 'ASC' : 'DESC'
        older_than = @external_api_client.metadata["OLDER_THAN"].to_f # in minutes

        raise 'ApiResource of another ApiNamespace cannot be deleted.'if api_namespace_id.to_s != @external_api_client.api_namespace_id.to_s

        api_resources_to_be_deleted = ApiResource.where(api_namespace_id: api_namespace_id).where("(EXTRACT (EPOCH FROM  now() - #{dimension} )::int/60) > ?", older_than).order("#{dimension} #{order}").limit(batch_size)

        ActiveRecord::Base.transaction do
          api_resources_to_be_deleted.each do |api_resource|
            api_resource.destroy!
          end
        end
      end
    end
    # at the end of the file we have to implicitly return the class 
    VacuumJob
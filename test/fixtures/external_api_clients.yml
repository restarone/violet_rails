
test:
  api_namespace: two
  slug: test-second
  label: Test API 2
  enabled: true
  metadata: {
              "api_key": "x-api-key-foo",
              "bearer_token": "foo"
            }
  model_definition: |
    class ExternalApiModelExample
      def initialize(parameters)  
        # do init stuff
      end
      def start
        return true
      end

      def log
        return true
      end
    end
    # at the end of the file we have to implicitly return the class 
    ExternalApiModelExample
open_json_server:
  api_namespace: two
  slug: test-second
  label: Test API 2
  enabled: true
  metadata:  {
                "api_key": "x-api-key-foo",
                "bearer_token": "foo"
              }
  model_definition: |
    class OpenJsonServer
      def initialize(parameters)  
        @external_api_client = parameters[:external_api_client]
        @base_url = "https://jsonplaceholder.typicode.com/todos/1"
      end
      def start
        response = HTTParty.get(@base_url).body
        @external_api_client.api_namespace.api_resources.create(
          properties: JSON.parse(response).deep_symbolize_keys
        )
      end

      def log
        return true
      end
    end
    # at the end of the file we have to implicitly return the class 
    OpenJsonServer
modmed:
  api_namespace: one
  slug: test-api
  label: Test API
  enabled: true
  metadata: {
              "api_key": "x-api-key-foo",
              "bearer_token": "foo"
            }
  model_definition: |
    # ex; 
    # modmed = ExternalApiClient.find_by(slug: ExternalApiClient::CLIENTS[:modmed][:name])
    # supervisor = modmed.run 
    # returns => External::ApiClients::Modmed instance so you can for eg:
    # supervisor.authenticate
    # supervisor.get_patients
    class External::ApiClients::Modmed
      def initialize(parameters)
        @external_api_client = parameters[:external_api_client]
        @metadata = @external_api_client.get_metadata
        @clinic_id = @metadata[:clinic_id]
        @auth_root = @metadata[:auth_base_url]
        @base_url = @metadata[:base_url_generic]

        @headers =  {
          'Content-Type': 'application/json',
          'x-api-key': @metadata[:api_key],
          'Authorization': "Bearer #{@metadata[:bearer_token]}"
        }
      end

      def start
        authentication_event = self.authenticate
        get_patients_event = self.get_patients
        random_patient_id = get_patients_event[:entry].sample[:resource][:id]
        get_patient_event = self.get_patient(random_patient_id)
        get_patient_documents_event = self.get_patient_documents(random_patient_id)
        get_patient_allergy_tolerance_event = self.get_patient_allergy_tolerance(random_patient_id)
        get_patient_medication_statement_event = self.get_patient_medication_statement(random_patient_id)
        # get_patient_service_request_event = self.get_clinic_patient_service_request(random_patient_id)

        doc = {
          get_patients: get_patients_event,
          random_patient_id: random_patient_id,
          get_patient_event: get_patient_event,
          get_patient_documents_event: get_patient_documents_event,
          get_patient_allergy_tolerance_event: get_patient_allergy_tolerance_event, 
          get_patient_medication_statement_event: get_patient_medication_statement_event
        }

        if authentication_event && get_patients_event
          self.reset_retries_after_success
        end
        ApiResource.create(api_namespace_id: @external_api_client.api_namespace.id,properties: doc)
        return true
      end

      def log
        return true
      end

      def get_patients
        endpoint = "#{@base_url}/#{@clinic_id}/ema/fhir/v2/Patient"
        response = HTTParty.get(endpoint, headers: @headers).body
        return JSON.parse(response).deep_symbolize_keys
      end

      def get_patient(patient_id)
        endpoint = "#{@base_url}/#{@clinic_id}/ema/fhir/v2/Patient/#{patient_id}"
        response = HTTParty.get(endpoint, headers: @headers).body
        return JSON.parse(response).deep_symbolize_keys
      end

      def get_patient_documents(patient_id)
        # search documents in postman looks the same as this #call but with an additional query parameter (_count)
        endpoint = "#{@base_url}/#{@clinic_id}/ema/fhir/v2/DocumentReference?patient=#{patient_id}"
        response = HTTParty.get(endpoint, headers: @headers).body
        return JSON.parse(response).deep_symbolize_keys
      end

      def get_patient_allergy_tolerance(patient_id)
        endpoint = "#{@base_url}/#{@clinic_id}/ema/fhir/v2/AllergyIntolerance?patient=#{patient_id}"
        response = HTTParty.get(endpoint, headers: @headers).body
        return JSON.parse(response).deep_symbolize_keys
      end

      def get_patient_medication_statement(patient_id)
        endpoint = "#{@base_url}/#{@clinic_id}/ema/fhir/v2/MedicationStatement?patient=#{patient_id}"
        response = HTTParty.get(endpoint, headers: @headers).body
        return JSON.parse(response).deep_symbolize_keys
      end

      def get_clinic_patient_service_request(patient_id)
        endpoint = "#{@base_url}/ema/fhir/v2/ServiceRequest?patient=#{patient_id}"
        response = HTTParty.get(endpoint, headers: @headers).body
        return JSON.parse(response).deep_symbolize_keys
      end

      def get_clinic_encounters
        endpoint = "#{@base_url}/#{@clinic_id}/ema/fhir/v2/Encounter"
        response = HTTParty.get(endpoint, headers: @headers).body
        return JSON.parse(response).deep_symbolize_keys
      end

      def get_clinic_encounter_diagnostic_report(encounter_id)
        endpoint = "#{@base_url}/ema/fhir/v2/DiagnosticReport?encounter=#{encounter_id}"
        response = HTTParty.get(endpoint, headers: @headers).body
        return JSON.parse(response).deep_symbolize_keys
      end

      def get_clinic_encounter_service_request(encounter_id)
        endpoint = "#{@base_url}/ema/fhir/v2/ServiceRequest?encounter=#{encounter_id}"
        response = HTTParty.get(endpoint, headers: @headers).body
        return JSON.parse(response).deep_symbolize_keys
      end

      def authenticate
        # returns
        # "{\"scope\":\"dermpmsandbox277\",\"token_type\":\"Bearer\",\"access_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJmaGlyX2lSSEdZIiwicG9sICAgICAgICAiOiJjaGFuZ2VtZSIsInVybFByZWZpeCI6ImRlcm1wbXNhbmRib3gyNzciLCJ2ZW5kb3IiOiJmaGlyX2lSSEdZQGRlcm1wbXNhbmRib3gyNzciLCJpc3MiOiJtb2RtZWQiLCJ0b2tlblR5cGUiOiJhY2Nlc3MiLCJqdGkiOiIyNTVmNTA3Y2JiMzE0MTNmODA3NmU0NTY1MmU1MjE2ZSJ9.edemcIlcVZBCijO92pTodHoLtTbcfkXiUbMmSOQ57_8\",\"refresh_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJmaGlyX2lSSEdZIiwidXJsUHJlZml4IjoiZGVybXBtc2FuZGJveDI3NyIsImlzcyI6Im1vZG1lZCIsInRva2VuVHlwZSI6InJlZnJlc2giLCJqdGkiOiI5OWFhNjQyOWM2ZjY0MTRhOGI4MzA4YzNhYmVkOGM5NSJ9.nPUaFhAs82rQWeV_mJP3_qOHn6VMmqPoGWCG1SwfXaI\"}"
        endpoint = "#{@auth_root}/ema-dev/firm/#{@clinic_id}/ema/ws/oauth2/grant"
        payload = {    
          "grant_type": @metadata[:grant_type],
          "username": @metadata[:username],
          "password": @metadata[:password],
        }
        response = HTTParty.post(endpoint,
          body: URI.encode_www_form(payload), 
          headers: { 
            'Content-Type': 'application/x-www-form-urlencoded',
            'x-api-key': @metadata[:api_key]
          }
        ).body
        response_obj = JSON.parse(response).deep_symbolize_keys
        external_api_client_meta = @external_api_client.get_metadata
        if response_obj[:access_token]
          external_api_client_meta[:bearer_token] = response_obj[:access_token]
          @external_api_client.set_metadata(external_api_client_meta)
          return true
        else
          raise StandardError.new "#authenticate: #{response_obj.to_s}"
        end
      end

      def reset_retries_after_success
        @external_api_client.update(retries: 0)
      end
    end
    # at the end of the file we have to implicitly return the class 
    External::ApiClients::Modmed
vacuum_job:
  api_namespace: one
  slug: vacuum-job
  label: VacuumJob
  enabled: true
  metadata: {
            'ORDER': 'descending',
            'DIMENSION': 'created_at',
            'BATCH_SIZE': '5',
            'API_NAMESPACE_ID': '1',
            'OLDER_THAN': '2880' # 2 days (in minutes)
          }
  model_definition: |
    class VacuumJob
      def initialize(parameters)  
        @external_api_client = parameters[:external_api_client]
      end

      def start
        # Fetching provided inputs (namespaceid, batch_size, dimension, order, time_before)
        api_namespace_id = @external_api_client.metadata["API_NAMESPACE_ID"]
        batch_size = @external_api_client.metadata["BATCH_SIZE"]
        dimension = @external_api_client.metadata["DIMENSION"]
        order = @external_api_client.metadata["ORDER"].upcase.starts_with?('ASC') ? 'ASC' : 'DESC'
        older_than = @external_api_client.metadata["OLDER_THAN"].to_f # in minutes

        raise 'ApiResource of another ApiNamespace cannot be deleted.'if api_namespace_id.to_s != @external_api_client.api_namespace_id.to_s

        api_resources_to_be_deleted = ApiResource.where(api_namespace_id: api_namespace_id).where("(EXTRACT (EPOCH FROM  now() - #{dimension} )::int/60) > ?", older_than).order("#{dimension} #{order}").limit(batch_size)

        ActiveRecord::Base.transaction do
          api_resources_to_be_deleted.each do |api_resource|
            api_resource.destroy!
          end
        end
      end
    end
    # at the end of the file we have to implicitly return the class 
    VacuumJob

mailchimp_plugin:
  api_namespace: mailchimp
  slug: mailchimp-plugin
  label: MailChimp
  enabled: true
  metadata: {
            'API_KEY': 'testkey',
            'SERVER_PREFIX': 'us9',
            'LIST_ID': 'valid_list_id',
          }
  model_definition: |
    class SyncToMailchimp
      def initialize(parameters)
        @external_api_client     = parameters[:external_api_client]
        @api_key                 = @external_api_client.metadata["API_KEY"]
        @unsynced_api_resources  = @external_api_client.api_namespace.api_resources.where("properties @> ?", {synced_to_mailchimp: false}.to_json)
        @mailchimp_uri           = "https://#{@external_api_client.metadata['SERVER_PREFIX']}.api.mailchimp.com/3.0/lists/#{@external_api_client.metadata['LIST_ID']}/members?skip_merge_validation=true"
        @custom_merge_fields_map = @external_api_client.metadata['CUSTOM_MERGE_FIELDS_MAP'] || {}
        @attr_to_exclude         = (@external_api_client.metadata['ATTR_TO_EXCLUDE'] || []) + @custom_merge_fields_map.keys + ['synced_to_mailchimp']
        @logger_namespace        = ApiNamespace.find_by(slug: @external_api_client.metadata["LOGGER_NAMESPACE"]) if @external_api_client.metadata["LOGGER_NAMESPACE"]
      end
      
      def start
        @unsynced_api_resources.each do |api_resource|
          begin
            merge_fields = api_resource.properties.except(*@attr_to_exclude).transform_keys(&:upcase).transform_values(&:to_s)

            @custom_merge_fields_map.each do |key, value|
              merge_fields[value.upcase] = api_resource.properties[key].to_s if value
            end

            response = HTTParty.post(@mailchimp_uri, 
              body: { 
                  email_address: api_resource.properties["email"],
                  status: "subscribed",
                  merge_fields: merge_fields,
                  tags: @external_api_client.metadata['TAGS'] || []
                }.to_json,

              headers: {
                  'Content-Type': 'application/json',
                  'Authorization': "Basic #{@api_key}" 
                } 
              )

            if response.success?
              api_resource.properties["synced_to_mailchimp"] = true
              api_resource.save
            end

            @logger_namespace.api_resources.create!(
              properties: {
                api_resource: api_resource.id,
                status: response.success? ? "success" : "error",
                response: JSON.parse(response.body),
                timestamp: Time.zone.now
              }
            ) if @logger_namespace

          rescue StandardError => e
            @logger_namespace.api_resources.create!(
              properties: {
                api_resource: api_resource.id,
                status: "error",
                response: { detail: e.message},
                timestamp: Time.zone.now
              }
            ) if @logger_namespace
          end
        end
      end
    end

    # at the end of the file we have to implicitly return the class 
    SyncToMailchimp